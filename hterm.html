<!DOCTYPE html>
<html>
	<head>
		<title>hterm test page</title>
		<meta charset='utf-8'/>
		<meta name="viewport" content="viewport-fit=cover, width=device-width, initial-scale=1, user-scalable=no">
		<!-- 
	  <script src='../dist/js/hterm_deps.js'></script>
	  <script src='../dist/js/hterm_resources.js'></script>
	  --> 
	  <!-- Dist version.-->
	  <script src='hterm_all.js'></script>
	   <style>
html {
	height: 100%;
}
body {
	position: absolute;
	height: 100%;
	width: 100%;
	overflow: hidden;
	margin: 0px;
	padding: 0px;
}
#terminal {
	display: block;
	position: relative;
	height: 100%;
	width: 100%;
	margin: 0px;
	padding: 0px;
}
	   </style>
	</head>

	<body>
		<div id='terminal' contenteditable='true'></div>
		<script>
			function initContent(io) {
				const ver = lib.resource.getData('libdot/changelog/version');
				const date = lib.resource.getData('libdot/changelog/date');
				const pkg = `libdot ${ver} (${date})`;
			};

            function luminance(color) {
				var colorArray = lib.colors.crackRGB(color);
				return colorArray[0] * 0.2126 + colorArray[1] * 0.7152 + colorArray[2] *  0.0722;
			}

            var lastDirectory = '';
            var fileList = [];
            var currentCommandCursorPosition;
            var autocompleteList = []; 
            var autocompleteOn = false;
            var autocompleteIndex = 0;

            function disableAutocompleteMenu() {
				printString('');
				autocompleteOn = false;
				autocompleteList = [];
				autocompleteIndex = 0;
			}

            // prints a string and move the rest of the command around, even if it is over multiple lines
            function printString(string) {
				var currentCommand = window.term_.io.currentCommand;
				var lineCursor = Math.floor((currentCommandCursorPosition + window.promptEnd)/ window.term_.screenSize.width);
				var lineEndCommand = Math.floor((currentCommand.length + window.promptEnd + string.length)/ window.term_.screenSize.width);
				if (((currentCommand.length < window.term_.screenSize.width) || (lineCursor ==  lineEndCommand)) && (!autocompleteOn)) {
					// simple version, we are on the last line (or there is only one line):
					window.term_.io.print(string); 
				} else {
					// More complicated version, we are several lines above. 
					// clear entire buffer, then reprint
					window.term_.io.print('\x1b[0J'); // delete display after cursor
					window.term_.io.print(string); 
					// print remainder of command line
					window.term_.io.print(currentCommand.slice(currentCommandCursorPosition, currentCommand.length))
					// move cursor back to where it was (don't use term.screen_.cursorPosition):
					var wcwidth = currentCommand.slice(currentCommandCursorPosition, currentCommand.length).length;
					for (var i = 0; i < wcwidth; i++) {
						window.term_.io.print('\b'); 
					}
				}
			}

            // prints a string for autocomplete and move the rest of the command around, even if it is over multiple lines.
            // keep the command as it is until autocomplete has been accepted.
            function printAutocompleteString(string) {
				var currentCommand = window.term_.io.currentCommand;
				var lineCursor = Math.floor((currentCommandCursorPosition + window.promptEnd)/ window.term_.screenSize.width);
				var lineEndCommand = Math.floor((currentCommand.length + window.promptEnd + string.length)/ window.term_.screenSize.width);
				// clear entire buffer, then reprint
				window.term_.io.print('\x1b[0J'); // delete display after cursor
				if (luminance(window.term_.getBackgroundColor()) < luminance(window.term_.getForegroundColor())) {
					// We are in dark mode. Use yellow font for higher contrast
					window.term_.io.print('\x1b[33m'); // yellow

				} else {
					window.term_.io.print('\x1b[32m'); // 
				}
				window.term_.io.print(string); 
				window.term_.io.print('\x1b[39m'); // 
				// print remainder of command line
				window.term_.io.print(currentCommand.slice(currentCommandCursorPosition, currentCommand.length))
				// move cursor back to where it was (don't use term.screen_.cursorPosition):
				var wcwidth = currentCommand.slice(currentCommandCursorPosition, currentCommand.length).length + string.length;
				for (var i = 0; i < wcwidth; i++) {
					window.term_.io.print('\b'); 
				}
			}

            function pickCurrentValue() {
				var currentCommand = window.term_.io.currentCommand;
				var cursorPosition = window.term_.screen_.cursorPosition.column - window.promptEnd;
				selected = autocompleteList[autocompleteIndex]; 
				printString(selected);
				window.term_.io.currentCommand = currentCommand.slice(0, currentCommandCursorPosition) + selected + 
					currentCommand.slice(currentCommandCursorPosition, currentCommand.length);
				// is not enough to push the rest of the command if it's longer than a line
				currentCommandCursorPosition += selected.length;
				disableAutocompleteMenu();
			}
            
            // called once the list of files has been updated, asynchronously. 
            function updateFileMenu() {
				var cursorPosition = window.term_.screen_.cursorPosition.column - window.promptEnd;
				updateAutocompleteMenu(window.term_.io, cursorPosition);
			}

            function updateAutocompleteMenu(io, cursorPosition) {
				var lastFound = '';
				// string to use for research: from beginning of line to cursor position
				var rootForMatch = io.currentCommand.slice(0, currentCommandCursorPosition);
				var predicate = rootForMatch;
				var n = predicate.lastIndexOf("|");
				if (n < predicate.length) {
					var predicate = predicate.substr(n + 1);
				}
				n = predicate.lastIndexOf(" ");
				while ((n > 0) && (predicate[n-1] == "\\")) { 
					// escaped space
					n = predicate.lastIndexOf(" ", n - 1);
				}
				if (n < predicate.length) {
					var predicate = predicate.substr(n + 1);
				}
				n = predicate.lastIndexOf(">");
				if (n < predicate.length) {
					var predicate = predicate.substr(n + 1);
				}
				if (predicate[0] == '-') return; // arguments to function, no autocomplete
				// we have the string to use for matching (predicate). Is it a file or a command?
				var beforePredicate = rootForMatch.substr(0, rootForMatch.lastIndexOf(predicate));
				// remove all trailing spaces:
				while ((beforePredicate.length > 0) && (beforePredicate.slice(-1) == " ")) {
					beforePredicate = beforePredicate.slice(0, beforePredicate.length - 1)
				}
				autocompleteIndex = 0; 
				var matchToCommands = false;
				if (beforePredicate.length == 0) {
					matchToCommands = true; // beginning of line, must be a command
				} else if (beforePredicate.slice(-1) == "|") {
					matchToCommands = true; // right after a pipe, must be a command
				}
				// otherwise, it's probably a file
				var numFound = 0; 
				var file = '';
				if (matchToCommands) { 
					for (var i = 0, len = commandList.length; i < len; i++) {
						if (commandList[i].startsWith(predicate)) {
							var value = commandList[i].replace(predicate, "") + ' '; // add a space at the end if it's a command; 
							autocompleteList[numFound] = value;
							lastFound = value; 
							numFound += 1;
						}
					}
				} else {
					if ((predicate[0] == "/") && (predicate.lastIndexOf("/") == 0)) {
						// special case for root
						directory = "/";
						file = predicate.substr(1);
					} else {
						var lastSlash = predicate.lastIndexOf("/");
						if ((predicate.length > 0) && (lastSlash > 0) && (lastSlash < predicate.length)) {
							var directory = predicate.substr(0, lastSlash); // include "/" in directory
							file = predicate.substr(lastSlash + 1); // don't include "/" in file name
						} else {
							var directory = ".";
							file = predicate;
						}
					}
					// Need to get list of files from directory. 
					if (directory == lastDirectory) {
						for (var i = 0, len = fileList.length; i < len; i++) {
							if (fileList[i].startsWith(file)) {
								var value = fileList[i].replace(file, "")
								autocompleteList[numFound] = value; 
								lastFound = value; 
								numFound += 1;
							}
						}
					} else {
						// asynchronous communication. Will have to execute the rest of the command too.
						window.webkit.messageHandlers.aShell.postMessage('listDirectory:' + directory);
					}
				}

				// substring of io.currentCommand, ending at currentCommandCursorPosition, going back until first space or "/"
				// list to use for autocomplete = commandList if at beginning of line (modulo spaces) or after | (module spaces)
				// list of files inside directory otherwise. e.g. "../Library/Preferences/" (going back until next space)
				// TODO: no autocomplete on file for commands that don't operate on files (difficult)
				if (numFound > 1) {
					// If list is not empty:
					autocompleteOn = true;
					while ((autocompleteList[autocompleteIndex][0] == ".") && (autocompleteIndex < autocompleteList.length - 1)) {
						autocompleteIndex += 1;
					} 
					if (autocompleteIndex == autocompleteList.length - 1) {
						// directory with only ".*" files
						autocompleteIndex = 0;
					}
					printAutocompleteString(autocompleteList[autocompleteIndex]);
				} else {
					if (numFound == 1) {
						printString(lastFound);
						io.currentCommand = io.currentCommand.slice(0, currentCommandCursorPosition) + lastFound + 
							io.currentCommand.slice(currentCommandCursorPosition, io.currentCommand.length);
						currentCommandCursorPosition += lastFound.length;
					}
					disableAutocompleteMenu(); 
				}
			}

            function setupHterm() {
				const term = new hterm.Terminal();
				// Default monospaced fonts installed: Menlo and Courier. 
				term.prefs_.set('font-family', 'Menlo');
				term.prefs_.set('font-size', 15);
				term.prefs_.set('cursor-blink', true); 
				term.setInsertMode(true);
				term.setReverseWraparound(true);
				term.setWraparound(true);
				// 
				term.onTerminalReady = function() {
					const io = this.io.push();
					io.onVTKeystroke = (string) => {
						/* if (window.commandRunning != '') {
						// interactive commands: send everything to the command
						// forward all keyboard input to the command:
		             		io.print(string);
							} else */ { 
								if (io.currentCommand === '') { 
									// new line, reset things:
									// where was the cursor when we started typing this command? 
									window.promptEnd = term.screen_.cursorPosition.column;
									// required because some commands can take several lines, especially on a phone.
									window.promptLine = term.screen_.cursorPosition.row;
									window.promptScroll = term.scrollPort_.getTopRowIndex();
									currentCommandCursorPosition = 0; 
								}
								var cursorPosition = term.screen_.cursorPosition.column - window.promptEnd;  // remove prompt length
								switch (string) {
									case '\r':
										if (autocompleteOn) {
											// Autocomplete menu being displayed + press return: select what's visible and remove
											pickCurrentValue();
											break;
										}
										// Before executing command, move to end of line if not already there:
										// Compute how many lines should we move downward:
										var lineCursor = Math.floor((currentCommandCursorPosition + window.promptEnd)/ term.screenSize.width);
										var lineEndCommand = Math.floor((io.currentCommand.length + window.promptEnd)/ term.screenSize.width);
										for (var i = 0; i < lineEndCommand - lineCursor; i++) {
											io.println('');
										}
										io.println('');
										if (window.commandRunning != '') {
											// The command takes care of the prompt. Just send the input data:
											window.webkit.messageHandlers.aShell.postMessage('input:' + io.currentCommand + '\n');
											// remove temporarily stored command -- if any
											if (window.maxCommandInsideCommandIndex < window.commandInsideCommandArray.length) {
												window.commandInsideCommandArray.pop();
											}
											// only store non-empty commands:
											// store commands sent:
											if (io.currentCommand.length > 0) {
												if (io.currentCommand != window.commandInsideCommandArray[window.maxCommandInsideCommandIndex - 1]) {
													// only add command to history if it is different from the last one:
													window.maxCommandInsideCommandIndex = window.commandInsideCommandArray.push(io.currentCommand); 
												}
											} 
											while (window.maxCommandInsideCommandIndex >= 100) {
												// We have stored more than 100 commands
												window.commandInsideCommandArray.shift(); // remove first element
												window.maxCommandInsideCommandIndex = window.commandInsideCommandArray.length;
											} 
											window.commandInsideCommandIndex = window.maxCommandInsideCommandIndex; 
										} else {
											if (io.currentCommand.length > 0) {
												// Now is the time where we send the command to iOS: 
												window.webkit.messageHandlers.aShell.postMessage('shell:' + io.currentCommand);
												// and reinitialize:
												window.commandRunning = io.currentCommand;
												// remove temporarily stored command -- if any
												if (window.maxCommandIndex < window.commandArray.length) {
													window.commandArray.pop();
												}
												if (io.currentCommand != window.commandArray[window.maxCommandIndex - 1]) {
													// only add command to history if it is different from the last one:
													window.maxCommandIndex = window.commandArray.push(window.commandRunning); 
													while (window.maxCommandIndex >= 100) {
														// We have stored more than 100 commands
														window.commandArray.shift(); // remove first element
														window.maxCommandIndex = window.commandArray.length;
													} 
													window.commandIndex = window.maxCommandIndex; 
												} 
												// clear history inside command:
												window.commandInsideCommandArray = [];
												window.maxCommandInsideCommandIndex = 0;
											} else {
												io.print(window.prompt); 
											}
										}
										io.currentCommand = '';
										break;
									case String.fromCharCode(127): // delete from iOS keyboard
										if (currentCommandCursorPosition > 0) { 
											var lineCursor = Math.floor((currentCommandCursorPosition + window.promptEnd)/ term.screenSize.width);
											var lineEndCommand = Math.floor((io.currentCommand.length + window.promptEnd)/ term.screenSize.width);
											if ((io.currentCommand.length < term.screenSize.width) || (lineCursor ==  lineEndCommand)) {
												// simple version, we are on the last line (or there is only one line):
												io.print('\b'); // move cursor back one char
												io.print('\x1b[1P'); // delete 1 character before cursor
											} else {
												// More complicated version, we are several lines above. 
												// clear entire buffer, then reprint
												io.print('\b'); // move cursor back one char
												io.print('\x1b[0J'); // delete display after cursor
												// print remainder of command line
												io.print(io.currentCommand.slice(currentCommandCursorPosition, io.currentCommand.length))
												// move cursor back to where it was (don't use term.screen_.cursorPosition):
												var wcwidth = io.currentCommand.slice(currentCommandCursorPosition, io.currentCommand.length).length;
												for (var i = 0; i < wcwidth; i++) {
													io.print('\b'); 
												}
											}
											// remove character from command at current position:
											io.currentCommand = io.currentCommand.slice(0, currentCommandCursorPosition - 1) + 
												io.currentCommand.slice(currentCommandCursorPosition, io.currentCommand.length); 
												
											// if popup menu being displayed, remove it: (or recompute it?)
											currentCommandCursorPosition -= 1;
											disableAutocompleteMenu();
										}
										break;
									case String.fromCharCode(27):  // Escape. Make popup menu disappear
										disableAutocompleteMenu();
										break;
									case String.fromCharCode(27) + "[A":  // Up arrow
										if (window.commandRunning != '') {
											if (window.commandInsideCommandIndex > 0) {
												if (window.commandInsideCommandIndex === window.maxCommandInsideCommandIndex) {
													// Store current command: 
													window.commandInsideCommandArray[window.commandInsideCommandIndex] = io.currentCommand;
												}
												io.print('\x1b[' + (window.promptLine + 1) + ';' + (window.promptEnd + 1) + 'H'); // move cursor back to initial position
												io.print('\x1b[0J'); // delete display after cursor
												window.commandInsideCommandIndex -= 1;
												io.currentCommand = window.commandInsideCommandArray[window.commandInsideCommandIndex]; 
												io.print(io.currentCommand);
												currentCommandCursorPosition = io.currentCommand.length;
											}
										} else {
											// popup menu being displayed, change it:
											if (autocompleteOn) {
												if (autocompleteIndex > 0) {
													autocompleteIndex -= 1; 
													printAutocompleteString(autocompleteList[autocompleteIndex]);
												}													
												break;
											}
											if (window.commandIndex > 0) {
												if (window.commandIndex === window.maxCommandIndex) {
													// Store current command: 
													window.commandArray[window.commandIndex] = io.currentCommand;
												}
												var scrolledLines = window.promptScroll - term.scrollPort_.getTopRowIndex();
												io.print('\x1b[' + (window.promptLine + scrolledLines + 1) + ';' + (window.promptEnd + 1) + 'H'); // move cursor to position at start of line
												io.print('\x1b[0J'); // delete display after cursor
												window.commandIndex -= 1;
												io.currentCommand = window.commandArray[window.commandIndex]; 
												io.print(io.currentCommand);
												currentCommandCursorPosition = io.currentCommand.length;
											} 
										}
										break;
									case String.fromCharCode(27) + "[B":  // Down arrow
										if (window.commandRunning != '') {
											if (window.commandInsideCommandIndex < window.maxCommandInsideCommandIndex) {
												io.print('\x1b[' + (window.promptLine + 1) + ';' + (window.promptEnd + 1) + 'H'); // move cursor to position at start of line
												io.print('\x1b[0J'); // delete display after cursor
												window.commandInsideCommandIndex += 1;
												io.currentCommand = window.commandInsideCommandArray[window.commandInsideCommandIndex]; 
												io.print(io.currentCommand);
												currentCommandCursorPosition = io.currentCommand.length;
											}
										} else {
											// popup menu being displayed, change it:
											if (autocompleteOn) {
												if (autocompleteIndex < autocompleteList.length - 1) {
													autocompleteIndex += 1; 
													printAutocompleteString(autocompleteList[autocompleteIndex]);
												}													
												break;
											}
											if (window.commandIndex < window.maxCommandIndex) {
												var scrolledLines = window.promptScroll - term.scrollPort_.getTopRowIndex();
												io.print('\x1b[' + (window.promptLine + scrolledLines + 1) + ';' + (window.promptEnd + 1) + 'H'); // move cursor to position at start of line
												io.print('\x1b[0J'); // delete display after cursor
												window.commandIndex += 1;
												io.currentCommand = window.commandArray[window.commandIndex]; 
												io.print(io.currentCommand);
												currentCommandCursorPosition = io.currentCommand.length;
											}
										}
										break;
									case String.fromCharCode(27) + "[D":  // Left arrow
										disableAutocompleteMenu();
										if (currentCommandCursorPosition > 0) { // prompt.length
											io.print('\b'); // move cursor back one char
											currentCommandCursorPosition -= 1;
										}
										break;
									case String.fromCharCode(27) + "[C":  // Right arrow
										// recompute complete menu? For now, disable it.
										disableAutocompleteMenu();
										if (currentCommandCursorPosition < io.currentCommand.length) {
											if (term.screen_.cursorPosition.column < term.screenSize.width - 1) {
												io.print('\x1b[1C'); // move cursor forward one char
											} else {
												io.print('\x1b[' + (term.screen_.cursorPosition.row + 2) + ';' + 0 + 'H'); // move cursor to start of next line

											}
											currentCommandCursorPosition += 1;
										}
										break; 
									case String.fromCharCode(9):  // Tab, so autocomplete
										if (window.commandRunning == '') {
											if (autocompleteOn) {
												// hit tab when menu already visible = select current
												pickCurrentValue();
											} else {
												// Work on autocomplete list / current command
												updateAutocompleteMenu(io, currentCommandCursorPosition); 
											}
										} else {
											// no autocomplete inside running commands. Just print 4 spaces.
											// (spaces because tab confuse hterm)
											io.currentCommand = io.currentCommand.slice(0, currentCommandCursorPosition) + "    " + 
												io.currentCommand.slice(currentCommandCursorPosition, io.currentCommand.length);
											printString("    ");
										}
										break;
									default:
										// For debugging:
										// var charcode = string.charCodeAt(0);
										// window.webkit.messageHandlers.aShell.postMessage('' + charcode + " = " + string);
										// insert character at cursor position
										printString(string);  // print before we update io.currentCommand
										io.currentCommand = io.currentCommand.slice(0, currentCommandCursorPosition) + string + 
											io.currentCommand.slice(currentCommandCursorPosition, io.currentCommand.length);
										var lineCursor = Math.floor((currentCommandCursorPosition + window.promptEnd)/ term.screenSize.width);
										var lineEndCommand = Math.floor((io.currentCommand.length + window.promptEnd)/ term.screenSize.width);
										currentCommandCursorPosition += string.length;
										if (autocompleteOn) {
											updateAutocompleteMenu(io, currentCommandCursorPosition); 
										}
										break;
								}
							}
					};
					io.sendString = io.print;
					initContent(io);
					io.print("> "); // first prompt
					this.setCursorVisible(true);
					this.setForegroundColor(window.foregroundColor);
					this.setBackgroundColor(window.backgroundColor);
					// this.keyboard.characterEncoding = 'raw';
					// this.keyboard.bindings.addBinding('F11', 'PASS');
					// this.keyboard.bindings.addBinding('Ctrl-R', 'PASS');
				};
				term.decorate(document.querySelector('#terminal'));
				
				term.installKeyboard();
				// Useful for console debugging.
				window.term_ = term;
				window.commandRunning = '';
				window.commandArray = new Array();
				window.commandInsideCommandArray = new Array();
				window.commandIndex = 0;
				window.maxCommandIndex = 0;
				window.commandInsideCommandIndex = 0;
				window.maxCommandInsideCommandIndex = 0;
				window.prompt = "> "; // prompt for commands, configurable
				window.promptEnd = 2; // prompt for commands, configurable
				window.promptLine = 0; // term line on which the prompt started
				window.promptScroll = 0; // scroll line on which the scrollPort was when the prompt started
			}

            window.onload = function() {
				lib.init(setupHterm);
				window.term_.focus(); 
			};
		</script>

	</body>
</html>
